# üöÄ Complete Azure Web App Deployment Pipeline
# ‚úÖ OIDC Authentication | üêç Python 3.10 | üîß Full CI/CD
# Updated with latest best practices and comprehensive testing

name: üéØ Main Production Deploy - ImageTool Azure

on:
  push:
    branches:
      - main
    paths:
      - 'src/backend/**'      # Backend code changes
      - 'requirements.txt'    # Dependencies updates
      - '.github/workflows/main_imagetool.yml'  # Workflow changes
  workflow_dispatch:          # Manual deployment option

permissions:
  id-token: write         # üîë CRITICAL: Required for OIDC federated credentials  
  contents: read          # üìñ Required for actions/checkout
  actions: read           # üé¨ Required for artifact operations

env:
  PYTHON_VERSION: '3.10'        # üêç Python version
  APP_NAME: 'imagetool'         # üåê Azure App Service name
  AZURE_WEBAPP_URL: 'https://imagetool-h4dmewahfmg4bkej.eastasia-01.azurewebsites.net'

jobs:
  build:
    name: üîß Build & Test Application
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1    # Shallow clone for faster checkout

      - name: üêç Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'      # Cache pip dependencies

      - name: ‚ö° Create Virtual Environment
        run: |
          python -m venv venv
          source venv/bin/activate
          python -m pip install --upgrade pip setuptools wheel
      
      - name: üì¶ Install Dependencies
        run: |
          source venv/bin/activate
          pip install -r requirements.txt
          pip list  # Show installed packages for debugging
        
      - name: üß™ Comprehensive Application Testing
        run: |
          source venv/bin/activate
          cd src/backend
          
          echo "üîç Testing Flask Application..."
          python -c "from app import app; print('‚úÖ Flask app imports successfully')"
          
          echo "üîç Testing Required Libraries..."
          python -c "import pypdf, PIL, numpy; print('‚úÖ All core libraries imported')"
          
          echo "üîç Testing Application Routes..."
          python -c "
          from app import app
          with app.test_client() as client:
              # Test if routes are defined
              print('üìç Available routes:')
              for rule in app.url_map.iter_rules():
                  print(f'  {rule.rule} [{rule.methods}]')
              print('‚úÖ Application routes loaded successfully')
          "
          
          echo "üéâ All tests passed!"

      - name: üìÅ Advanced Deployment Package Creation
        run: |
          echo "üèóÔ∏è Creating optimized deployment package..."
          
          # Create deployment directory
          mkdir -p deployment-package
          
          # Copy backend files
          cp -r src/backend/* deployment-package/
          
          # Copy requirements.txt to deployment package
          cp requirements.txt deployment-package/
          
          # Create optimized startup.py for Azure App Service
          cat > deployment-package/startup.py << 'EOF'
          #!/usr/bin/env python3
          """
          üöÄ Azure App Service Startup Script
          Optimized for production deployment with proper error handling
          """
          import os
          import sys
          import logging
          from app import app
          
          # Configure logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
          )
          logger = logging.getLogger(__name__)
          
          if __name__ == "__main__":
              try:
                  port = int(os.environ.get('PORT', 8000))
                  logger.info(f"üåê Starting Flask app on port {port}")
                  
                  # Production-ready configuration
                  app.run(
                      host='0.0.0.0', 
                      port=port, 
                      debug=False,
                      threaded=True
                  )
              except Exception as e:
                  logger.error(f"‚ùå Failed to start application: {e}")
                  sys.exit(1)
          EOF
          
          # Create enhanced web.config for Azure IIS
          cat > deployment-package/web.config << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <system.webServer>
              <handlers>
                <add name="PythonHandler" path="*" verb="*" modules="httpPlatformHandler" resourceType="Unspecified"/>
              </handlers>
              <httpPlatform 
                processPath="python" 
                arguments="startup.py" 
                stdoutLogEnabled="true" 
                stdoutLogFile=".\logs\python.log" 
                startupTimeLimit="120" 
                requestTimeout="604800">
                <environmentVariables>
                  <environmentVariable name="PYTHONPATH" value="." />
                  <environmentVariable name="PORT" value="8000" />
                  <environmentVariable name="FLASK_ENV" value="production" />
                  <environmentVariable name="PYTHONUNBUFFERED" value="1" />
                </environmentVariables>
              </httpPlatform>
              
              <!-- Security headers -->
              <httpProtocol>
                <customHeaders>
                  <add name="X-Content-Type-Options" value="nosniff" />
                  <add name="X-Frame-Options" value="DENY" />
                  <add name="X-XSS-Protection" value="1; mode=block" />
                </customHeaders>
              </httpProtocol>
              
              <!-- Error handling -->
              <httpErrors errorMode="Detailed" />
            </system.webServer>
          </configuration>
          EOF
          
          # Create .deployment file for Azure
          cat > deployment-package/.deployment << 'EOF'
          [config]
          command = python -m pip install -r requirements.txt
          EOF
          
          echo "‚úÖ Deployment package created successfully"
          echo "üì¶ Package contents:"
          ls -la deployment-package/

      - name: üì§ Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: production-flask-app
          path: deployment-package/
          retention-days: 30
          compression-level: 6

  deploy:
    name: üöÄ Deploy to Azure Production
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 15
    permissions:
      id-token: write         # üîë CRITICAL: Required for OIDC token
      contents: read          # üìñ Required for basic operations
      actions: read           # üé¨ Required for artifact download

    steps:
      - name: üì• Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: production-flask-app
          path: ./app-package
      
      - name: üîê Azure Login (OIDC Federated Credentials)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: üåê Deploy to Azure Web App
        uses: azure/webapps-deploy@v3
        id: deploy-to-webapp
        with:
          app-name: ${{ env.APP_NAME }}
          slot-name: 'Production'
          package: './app-package'
          
      - name: üîç Pre-Deployment Verification
        run: |
          echo "‚è≥ Waiting for Azure deployment to stabilize..."
          echo "üéØ Target URL: ${{ env.AZURE_WEBAPP_URL }}"
          sleep 90  # Extended wait for complex deployments
          
      - name: üß™ Comprehensive Post-Deployment Testing
        run: |
          echo "üîç Running comprehensive endpoint tests..."
          
          # Function to test endpoint with retries
          test_endpoint() {
            local url=$1
            local name=$2
            local max_attempts=3
            local wait_time=10
            
            for attempt in $(seq 1 $max_attempts); do
              echo "üîÑ Testing $name (attempt $attempt/$max_attempts)..."
              
              if curl -f -s --max-time 30 "$url" > /dev/null; then
                echo "‚úÖ $name endpoint: SUCCESS"
                curl -s --max-time 30 "$url" | head -5
                return 0
              else
                echo "‚ö†Ô∏è $name endpoint failed on attempt $attempt"
                if [ $attempt -lt $max_attempts ]; then
                  echo "‚è≥ Waiting ${wait_time}s before retry..."
                  sleep $wait_time
                fi
              fi
            done
            
            echo "‚ùå $name endpoint: FAILED after $max_attempts attempts"
            echo "üîç Debugging info:"
            curl -v "$url" || true
            return 1
          }
          
          # Test critical endpoints
          echo "üéØ Testing application endpoints..."
          
          test_endpoint "${{ env.AZURE_WEBAPP_URL }}/ping" "Ping"
          ping_result=$?
          
          test_endpoint "${{ env.AZURE_WEBAPP_URL }}/health" "Health Check"
          health_result=$?
          
          # Test root endpoint
          test_endpoint "${{ env.AZURE_WEBAPP_URL }}/" "Root Application"
          root_result=$?
          
          # Summary
          echo ""
          echo "üìä DEPLOYMENT TEST SUMMARY:"
          echo "================================"
          [ $ping_result -eq 0 ] && echo "‚úÖ Ping endpoint: WORKING" || echo "‚ùå Ping endpoint: FAILED"
          [ $health_result -eq 0 ] && echo "‚úÖ Health endpoint: WORKING" || echo "‚ùå Health endpoint: FAILED"  
          [ $root_result -eq 0 ] && echo "‚úÖ Root endpoint: WORKING" || echo "‚ùå Root endpoint: FAILED"
          echo "================================"
          
          # Overall result
          if [ $ping_result -eq 0 ] && [ $health_result -eq 0 ]; then
            echo "üéâ DEPLOYMENT SUCCESSFUL! All critical endpoints are working."
            exit 0
          else
            echo "üí• DEPLOYMENT VERIFICATION FAILED! Some endpoints are not responding."
            exit 1
          fi
