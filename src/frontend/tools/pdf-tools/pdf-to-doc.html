<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Cache Control for Development -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>PDF to DOC Converter - Convert PDF to Word Document Online | ImagePDF Toolkit</title>
    <meta name="description" content="Convert PDF files to DOC/DOCX format online. Free PDF to Word converter with high accuracy. No uploads, 100% client-side processing.">
    <meta name="keywords" content="pdf to doc, pdf to word, pdf converter, pdf to docx, convert pdf">
    <meta name="author" content="ImagePDF Toolkit">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="PDF to DOC Converter - Convert PDF to Word Document Online">
    <meta property="og:description" content="Convert PDF files to DOC/DOCX format online. Free PDF to Word converter with high accuracy.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://techuhat.github.io/toolkit/tools/pdf-to-doc.html">
    
    <!-- Additional SEO Meta Tags -->
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="theme-color" content="#4F46E5">
    <link rel="canonical" href="https://techuhat.github.io/toolkit/tools/pdf-to-doc.html">
    
    <!-- Performance Optimization -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="format-detection" content="telephone=no">
    <link rel="preload" href="../../../../public/styles.min.css?v=2.3.1" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="../../../../public/css/premium-buttons.css?v=2.3.1" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="../script.js?v=2.3.1" as="script">
    
    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "PDF to DOC Converter",
        "description": "Convert PDF files to DOC/DOCX format online. Free PDF to Word converter with high accuracy.",
        "url": "https://techuhat.github.io/toolkit/tools/pdf-to-doc.html",
        "applicationCategory": "DocumentConverter",
        "operatingSystem": "Any",
        "browserRequirements": "Requires JavaScript. Requires HTML5.",
        "softwareVersion": "2.0",
        "author": {
            "@type": "Organization",
            "name": "TechUhat",
            "url": "https://github.com/techuhat"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="../../../../public/styles.min.css?v=2.3.1">
    <link rel="stylesheet" href="../../../../public/tailwind-complete.css?v=2.3.1">
    <link rel="stylesheet" href="../../../../public/css/all.min.css?v=2.3.1">
    <link rel="stylesheet" href="../../../../public/css/premium-buttons.css?v=2.3.1">
    
    <!-- Custom styles to fix diagonal line issues and clean animations -->
    <style>
        /* Remove any diagonal striped animations from progress bars */
        .progress-bar, #progress-bar {
            background: linear-gradient(90deg, #3b82f6, #1d4ed8) !important;
            background-image: none !important;
            animation: none !important;
        }
        
        /* Ensure no pseudo-elements add diagonal lines */
        .progress-bar::before, .progress-bar::after,
        #progress-bar::before, #progress-bar::after {
            display: none !important;
        }
        
        /* Clean progress bar container */
        #progress-container {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
        }
        
        /* Smooth animations only for intended elements */
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* Remove any scanning line effects */
        .scanning-line, .scanner-line, .scan-effect {
            display: none !important;
        }
        
        /* Custom error display styling */
        #error-display {
            transition: all 0.3s ease-in-out;
        }
        
        #conversion-status {
            transition: all 0.3s ease-in-out;
        }
        
        /* Remove any unwanted transforms or rotations from progress elements */
        #progress-container *, #conversion-status *, #error-display * {
            transform: none !important;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
    
    <!-- Theme initialization script - runs immediately -->
    <script>
        (function() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                if (document.documentElement && document.documentElement.classList) {
                    document.documentElement.classList.add('dark');
                }
            } else {
                if (document.documentElement && document.documentElement.classList) {
                    document.documentElement.classList.remove('dark');
                }
            }
        })();
    </script>
    
    <style>
        :root {
            --primary-color: #7c3aed;
            --primary-hover: #6d28d9;
        }
        
        .tool-gradient {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
        }
        
        /* Complete Dark mode styles */
        .dark {
            color-scheme: dark;
        }
        
        .dark body {
            background-color: #111827 !important;
            color: #f9fafb !important;
        }
        
        .dark .bg-white {
            background-color: #1f2937 !important;
        }
        
        .dark .bg-gray-50 {
            background-color: #111827 !important;
        }
        
        .dark .bg-gray-100 {
            background-color: #374151 !important;
        }
        
        .dark .text-gray-900 {
            color: #f9fafb !important;
        }
        
        .dark .text-gray-600 {
            color: #d1d5db !important;
        }
        
        .dark .text-gray-500 {
            color: #9ca3af !important;
        }
        
        .dark .border-gray-200 {
            border-color: #374151 !important;
        }
        
        .dark .border {
            border-color: #4b5563 !important;
        }
        
        .theme-transition {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        /* Day/Night Toggle Switch Styles */
        .toggleWrapper {
            position: relative !important;
            overflow: hidden !important;
            padding: 0 !important;
            display: inline-block !important;
        }

        .toggleWrapper input {
            position: absolute !important;
            left: -9999px !important;
            opacity: 0 !important;
        }

        /* Default state - Day mode */
        .toggle {
            cursor: pointer !important;
            display: inline-block !important;
            position: relative !important;
            width: 45px !important;
            height: 25px !important;
            background-color: #83D8FF !important;
            border-radius: 84px !important;
            transition: background-color 200ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        .toggle__handler {
            display: inline-block !important;
            position: relative !important;
            z-index: 1 !important;
            top: 2px !important;
            left: 2px !important;
            width: 21px !important;
            height: 21px !important;
            background-color: #FFCF96 !important;
            border-radius: 50px !important;
            box-shadow: 0 2px 6px rgba(0,0,0,.3) !important;
            transition: all 400ms cubic-bezier(0.68, -0.55, 0.265, 1.55) !important;
            transform: rotate(-45deg) !important;
        }

        .crater {
            position: absolute !important;
            background-color: #E8CDA5 !important;
            opacity: 0 !important;
            transition: opacity 200ms ease-in-out !important;
            border-radius: 100% !important;
        }

        .crater--1 {
            top: 9px !important;
            left: 5px !important;
            width: 2px !important;
            height: 2px !important;
        }

        .crater--2 {
            top: 14px !important;
            left: 11px !important;
            width: 3px !important;
            height: 3px !important;
        }

        .crater--3 {
            top: 5px !important;
            left: 12px !important;
            width: 4px !important;
            height: 4px !important;
        }

        .star {
            position: absolute !important;
            background-color: #ffffff !important;
            transition: all 300ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
            border-radius: 50% !important;
        }

        .star--1 {
            top: 5px !important;
            left: 17px !important;
            z-index: 0 !important;
            width: 15px !important;
            height: 2px !important;
        }

        .star--2 {
            top: 9px !important;
            left: 14px !important;
            z-index: 1 !important;
            width: 15px !important;
            height: 2px !important;
        }

        .star--3 {
            top: 14px !important;
            left: 20px !important;
            z-index: 0 !important;
            width: 15px !important;
            height: 2px !important;
        }

        .star--4,
        .star--5,
        .star--6 {
            opacity: 0 !important;
            transition: all 300ms 0 cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        .star--4 {
            top: 8px !important;
            left: 6px !important;
            z-index: 0 !important;
            width: 1px !important;
            height: 1px !important;
            transform: translate3d(3px,0,0) !important;
        }

        .star--5 {
            top: 16px !important;
            left: 9px !important;
            z-index: 0 !important;
            width: 1.5px !important;
            height: 1.5px !important;
            transform: translate3d(3px,0,0) !important;
        }

        .star--6 {
            top: 18px !important;
            left: 14px !important;
            z-index: 0 !important;
            width: 1px !important;
            height: 1px !important;
            transform: translate3d(3px,0,0) !important;
        }

        /* Night mode - Checked state styles */
        input:checked + .toggle {
            background-color: #749DD6 !important;
        }

        input:checked + .toggle .toggle__handler {
            background-color: #FFE5B5 !important;
            transform: translate3d(20px, 0, 0) rotate(0deg) !important;
        }

        input:checked + .toggle .crater {
            opacity: 1 !important;
        }

        input:checked + .toggle .star--1 {
            width: 1px !important;
            height: 1px !important;
        }

        input:checked + .toggle .star--2 {
            width: 2px !important;
            height: 2px !important;
            transform: translate3d(-5px, 0, 0) !important;
        }

        input:checked + .toggle .star--3 {
            width: 1px !important;
            height: 1px !important;
            transform: translate3d(-7px, 0, 0) !important;
        }

        input:checked + .toggle .star--4,
        input:checked + .toggle .star--5,
        input:checked + .toggle .star--6 {
            opacity: 1 !important;
            transform: translate3d(0,0,0) !important;
        }

        input:checked + .toggle .star--4 {
            transition: all 300ms 200ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        input:checked + .toggle .star--5 {
            transition: all 300ms 300ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        input:checked + .toggle .star--6 {
            transition: all 300ms 400ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        .glass-effect {
            background: rgba(248, 250, 252, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(226, 232, 240, 0.3);
        }
        
        .dark .glass-effect {
            background: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .dark .gradient-bg {
            background: linear-gradient(135deg, #4c1d95 0%, #1e1b4b 100%);
        }

        .file-drop-zone {
            border: 2px dashed #d1d5db;
            transition: all 0.3s ease;
            background: rgba(248, 250, 252, 0.5);
        }
        
        .file-drop-zone.drag-over {
            border-color: #4f46e5;
            background-color: rgba(79, 70, 229, 0.05);
        }
        
        .dark .file-drop-zone {
            border-color: #4b5563;
            background: rgba(31, 41, 55, 0.5);
        }
        
        .dark .file-drop-zone.drag-over {
            border-color: #6366f1;
            background-color: rgba(99, 102, 241, 0.1);
        }
        
        /* Day/Night Toggle Switch Styles */
        .toggleWrapper {
            position: relative !important;
            overflow: hidden !important;
            padding: 0 !important;
            display: inline-block !important;
        }

        .toggleWrapper input {
            position: absolute !important;
            left: -9999px !important;
            opacity: 0 !important;
        }

        /* Default state - Day mode */
        .toggle {
            cursor: pointer !important;
            display: inline-block !important;
            position: relative !important;
            width: 45px !important;
            height: 25px !important;
            background-color: #83D8FF !important;
            border-radius: 84px !important;
            transition: background-color 200ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        .toggle__handler {
            display: inline-block !important;
            position: relative !important;
            z-index: 1 !important;
            top: 2px !important;
            left: 2px !important;
            width: 21px !important;
            height: 21px !important;
            background-color: #FFCF96 !important;
            border-radius: 50px !important;
            box-shadow: 0 2px 6px rgba(0,0,0,.3) !important;
            transition: all 400ms cubic-bezier(0.68, -0.55, 0.265, 1.55) !important;
            transform: rotate(-45deg) !important;
        }

        .crater {
            position: absolute !important;
            background-color: #E8CDA5 !important;
            opacity: 0 !important;
            transition: opacity 200ms ease-in-out !important;
            border-radius: 100% !important;
        }

        .crater--1 {
            top: 9px !important;
            left: 5px !important;
            width: 2px !important;
            height: 2px !important;
        }

        .crater--2 {
            top: 14px !important;
            left: 11px !important;
            width: 3px !important;
            height: 3px !important;
        }

        .crater--3 {
            top: 5px !important;
            left: 12px !important;
            width: 4px !important;
            height: 4px !important;
        }

        .star {
            position: absolute !important;
            background-color: #ffffff !important;
            transition: all 300ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
            border-radius: 50% !important;
        }

        .star--1 {
            top: 5px !important;
            left: 17px !important;
            z-index: 0 !important;
            width: 15px !important;
            height: 2px !important;
        }

        .star--2 {
            top: 9px !important;
            left: 14px !important;
            z-index: 1 !important;
            width: 15px !important;
            height: 2px !important;
        }

        .star--3 {
            top: 14px !important;
            left: 20px !important;
            z-index: 0 !important;
            width: 15px !important;
            height: 2px !important;
        }

        .star--4,
        .star--5,
        .star--6 {
            opacity: 0 !important;
            transition: all 300ms 0 cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        .star--4 {
            top: 8px !important;
            left: 6px !important;
            z-index: 0 !important;
            width: 1px !important;
            height: 1px !important;
            transform: translate3d(3px,0,0) !important;
        }

        .star--5 {
            top: 16px !important;
            left: 9px !important;
            z-index: 0 !important;
            width: 1.5px !important;
            height: 1.5px !important;
            transform: translate3d(3px,0,0) !important;
        }

        .star--6 {
            top: 18px !important;
            left: 14px !important;
            z-index: 0 !important;
            width: 1px !important;
            height: 1px !important;
            transform: translate3d(3px,0,0) !important;
        }

        /* Night mode - Checked state styles */
        input:checked + .toggle {
            background-color: #749DD6 !important;
        }

        input:checked + .toggle .toggle__handler {
            background-color: #FFE5B5 !important;
            transform: translate3d(20px, 0, 0) rotate(0deg) !important;
        }

        input:checked + .toggle .crater {
            opacity: 1 !important;
        }

        input:checked + .toggle .star--1 {
            width: 1px !important;
            height: 1px !important;
        }

        input:checked + .toggle .star--2 {
            width: 2px !important;
            height: 2px !important;
            transform: translate3d(-5px, 0, 0) !important;
        }

        input:checked + .toggle .star--3 {
            width: 1px !important;
            height: 1px !important;
            transform: translate3d(-7px, 0, 0) !important;
        }

        input:checked + .toggle .star--4,
        input:checked + .toggle .star--5,
        input:checked + .toggle .star--6 {
            opacity: 1 !important;
            transform: translate3d(0,0,0) !important;
        }

        input:checked + .toggle .star--4 {
            transition: all 300ms 200ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        input:checked + .toggle .star--5 {
            transition: all 300ms 300ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }

        input:checked + .toggle .star--6 {
            transition: all 300ms 400ms cubic-bezier(0.445, 0.05, 0.55, 0.95) !important;
        }
    </style>
</head>
<body class="theme-transition bg-slate-50 dark:bg-gray-900 text-slate-800 dark:text-gray-100 min-h-screen">
    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>
    
    <!-- Progress Bar - Simple and Clean -->
    <div id="progress-container" class="fixed top-0 left-0 w-full h-1 z-40 hidden">
        <div id="progress-bar" class="h-full bg-gradient-to-r from-blue-500 to-purple-600 transition-all duration-300 ease-out" style="width: 0%"></div>
    </div>
    
    <!-- Navigation -->
    <nav class="glass-effect sticky top-0 z-30 backdrop-blur-lg" role="navigation" aria-label="Main navigation">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-3">
                    <a href="../../../../index.html" class="flex items-center space-x-3 hover:opacity-80 transition-opacity">
                        <div class="w-10 h-10 bg-gradient-to-br from-blue-600 via-purple-600 to-indigo-700 rounded-xl flex items-center justify-center shadow-lg">
                            <svg class="w-5 h-5 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-4-4h-4v-2h4v2zm0-4H9v-2h6v2z"/>
                            </svg>
                        </div>
                        <div class="flex flex-col">
                            <h1 class="text-xl font-bold text-gray-900 dark:text-white">ImagePDF Toolkit</h1>
                            <span class="text-xs text-gray-500 dark:text-gray-400 font-medium">Professional Tools</span>
                        </div>
                    </a>
                </div>
                
                <div class="flex items-center space-x-4">
                    <!-- Theme Toggle -->
                    <div class="toggleWrapper">
                        <input type="checkbox" id="dn" aria-label="Toggle dark mode" />
                        <label for="dn" class="toggle" aria-label="Dark mode toggle">
                            <span class="toggle__handler" aria-hidden="true">
                                <span class="crater crater--1"></span>
                                <span class="crater crater--2"></span>
                                <span class="crater crater--3"></span>
                            </span>
                            <span class="star star--1" aria-hidden="true"></span>
                            <span class="star star--2" aria-hidden="true"></span>
                            <span class="star star--3" aria-hidden="true"></span>
                            <span class="star star--4" aria-hidden="true"></span>
                            <span class="star star--5" aria-hidden="true"></span>
                            <span class="star star--6" aria-hidden="true"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </nav>
    
    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Hero Section -->
        <section class="text-center mb-12">
            <div class="inline-flex items-center justify-center w-20 h-20 tool-gradient rounded-2xl shadow-lg mb-6">
                <svg class="w-10 h-10 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm4 18H6V4h7v5h5v11z"/>
                </svg>
            </div>
            <h1 class="text-4xl font-bold mb-4 text-gray-900 dark:text-white">
                PDF to DOC Converter
            </h1>
            <p class="text-xl text-gray-600 dark:text-gray-300 mb-8">
                Convert PDF files to DOC/DOCX format with high accuracy. Supports both client-side processing and advanced server-side conversion for complex PDFs.
            </p>
        </section>
        
        <!-- Conversion Mode Selection -->
        <div class="max-w-2xl mx-auto mb-8">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Choose Conversion Method</h3>
                <div id="backend-status" class="flex items-center text-sm">
                    <div class="w-2 h-2 bg-yellow-400 rounded-full mr-2 animate-pulse"></div>
                    <span class="text-gray-500 dark:text-gray-400">Checking server...</span>
                </div>
            </div>
            <div class="grid md:grid-cols-2 gap-4">
                <!-- Client-side Mode -->
                <div class="conversion-mode-card bg-white dark:bg-gray-800 rounded-xl p-6 border-2 border-blue-200 dark:border-blue-700 cursor-pointer transition-all hover:border-blue-400 dark:hover:border-blue-500" onclick="selectConversionMode('client')">
                    <div class="flex items-center mb-3">
                        <input type="radio" id="client-mode" name="conversion-mode" value="client" checked class="mr-3">
                        <label for="client-mode" class="text-lg font-semibold text-gray-900 dark:text-white cursor-pointer">Client-side Processing</label>
                    </div>
                    <div class="text-sm text-gray-600 dark:text-gray-300 mb-3">
                        <div class="flex items-center mb-2">
                            <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                            </svg>
                            <span>100% Private & Secure</span>
                        </div>
                        <div class="flex items-center mb-2">
                            <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                            </svg>
                            <span>No File Upload Required</span>
                        </div>
                        <div class="flex items-center text-yellow-600 dark:text-yellow-400">
                            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                            </svg>
                            <span>Basic text extraction only</span>
                        </div>
                    </div>
                </div>
                
                <!-- Server-side Mode -->
                <div class="conversion-mode-card bg-white dark:bg-gray-800 rounded-xl p-6 border-2 border-gray-200 dark:border-gray-600 cursor-pointer transition-all hover:border-purple-400 dark:hover:border-purple-500" onclick="selectConversionMode('server')">
                    <div class="flex items-center mb-3">
                        <input type="radio" id="server-mode" name="conversion-mode" value="server" class="mr-3">
                        <label for="server-mode" class="text-lg font-semibold text-gray-900 dark:text-white cursor-pointer">Server Processing</label>
                        <span class="ml-2 bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 text-xs px-2 py-1 rounded-full">Cloud</span>
                    </div>
                    <div class="text-sm text-gray-600 dark:text-gray-300 mb-3">
                        <div class="flex items-center mb-2">
                            <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                            </svg>
                            <span>Serverless Cloud Processing</span>
                        </div>
                        <div class="flex items-center mb-2">
                            <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                            </svg>
                            <span>Advanced Text + Images</span>
                        </div>
                        <div class="flex items-center mb-2">
                            <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                            </svg>
                            <span>Global CDN & Auto-scaling</span>
                        </div>
                        <div class="flex items-center text-purple-600 dark:text-purple-400">
                            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                            </svg>
                            <span>Powered by Microsoft Azure</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- File Upload Area -->
        <div class="file-drop-zone rounded-xl p-8 text-center mb-8" id="fileDropZone">
            <div class="max-w-md mx-auto">
                <div class="w-20 h-20 bg-gradient-to-br from-blue-100 to-purple-100 dark:from-blue-900 dark:to-purple-900 rounded-full flex items-center justify-center mx-auto mb-4">
                    <svg class="w-10 h-10 text-blue-600 dark:text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm4 18H6V4h7v5h5v11z"/>
                    </svg>
                </div>
                <h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">
                    Drop PDF files here
                </h3>
                <p class="text-gray-600 dark:text-gray-400 mb-4">
                    or click to browse files
                </p>
                <input type="file" id="file-input" accept=".pdf" multiple class="hidden">
                <button onclick="document.getElementById('file-input').click()" class="btn-base btn-secondary btn-lg">
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11z"/>
                    </svg>
                    Choose PDF Files
                </button>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-4 file-size-limit">
                    Supports up to 10 PDF files, max 50MB each
                </p>
            </div>
        </div>
        
        <!-- File List -->
        <div id="file-list" class="mb-8"></div>
        
        <!-- Error Display Section -->
        <div id="error-display" class="hidden bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4 mb-6">
            <div class="flex items-start">
                <div class="flex-shrink-0">
                    <svg class="w-5 h-5 text-red-400 mt-0.5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2L1 21h22L12 2zm0 3.5L20.5 19h-17L12 5.5zM11 16v2h2v-2h-2zm0-6v4h2v-4h-2z"/>
                    </svg>
                </div>
                <div class="ml-3 flex-1">
                    <h3 class="text-sm font-medium text-red-800 dark:text-red-200 mb-2">
                        Conversion Errors
                    </h3>
                    <div id="error-list" class="text-sm text-red-700 dark:text-red-300 space-y-1">
                        <!-- Error messages will be inserted here -->
                    </div>
                    <button id="dismiss-errors" class="mt-3 text-sm text-red-600 dark:text-red-400 hover:text-red-800 dark:hover:text-red-200 underline">
                        Dismiss
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Conversion Progress Status -->
        <div id="conversion-status" class="hidden bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-6">
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    <svg id="status-icon" class="w-5 h-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                </div>
                <div class="ml-3">
                    <h3 id="status-title" class="text-sm font-medium text-blue-800 dark:text-blue-200">
                        Processing Files...
                    </h3>
                    <p id="status-message" class="text-sm text-blue-700 dark:text-blue-300 mt-1">
                        Initializing PDF processor...
                    </p>
                </div>
            </div>
        </div>
        
        <!-- Convert Button -->
        <div class="text-center mb-8 space-y-4">
            <button id="process-btn" class="btn-base btn-premium btn-xl" disabled>
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                Convert PDF to DOC
            </button>
            <button id="download-btn" class="btn-base btn-success btn-xl hidden" disabled>
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"/>
                </svg>
                Download Converted Files
            </button>
        </div>
    </main>
    
    <!-- Back to Tools Button -->
    <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8 text-center">
        <a href="../../../../index.html#tools" class="inline-flex items-center px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Back to tools section">
            <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
            Back to Tools
        </a>
    </div>
    
    <!-- Footer -->
    <footer class="bg-gray-900 text-white py-12" role="contentinfo" aria-label="Site footer">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="grid md:grid-cols-4 gap-8">
                <div>
                    <div class="flex items-center space-x-3 mb-4">
                        <div class="w-10 h-10 bg-gradient-to-br from-blue-600 via-purple-600 to-indigo-700 rounded-xl flex items-center justify-center shadow-lg" aria-hidden="true">
                            <div class="relative">
                                <svg class="w-5 h-5 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z M8.5 12.5l2.5 3 3.5-4.5 4.5 6H5l3.5-4.5z"/></svg>
                                <svg class="w-4 h-4 text-blue-200 absolute -top-1 -right-1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z M8.5 12.5l2.5 3 3.5-4.5 4.5 6H5l3.5-4.5z"/></svg>
                            </div>
                        </div>
                        <div class="flex flex-col">
                            <span class="text-xl font-bold text-white">ImagePDF Toolkit</span>
                            <span class="text-xs text-gray-400 font-medium">Professional Tools</span>
                        </div>
                    </div>
                    <p class="text-gray-400">Professional image and PDF processing tools for modern workflows.</p>
                </div>
                
                <div>
                    <h4 class="font-semibold mb-4">Tools</h4>
                    <ul class="space-y-2 text-gray-400">
                        <li><a href="image-to-pdf.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">Image to PDF</a></li>
                        <li><a href="pdf-to-images.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">PDF to Images</a></li>
                        <li><a href="image-compressor.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">Image Compressor</a></li>
                        <li><a href="image-resizer.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">Image Resizer</a></li>
                        <li><a href="format-converter.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">Format Converter</a></li>
                        <li><a href="batch-processor.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">Batch Processor</a></li>
                        <li><a href="pdf-to-doc.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">PDF to DOC</a></li>
                        <li><a href="../utility-tools/qr-generator.html" class="hover:text-white transition-colors cursor-pointer hover:translate-x-1 transform duration-200 inline-block">QR Code Generator</a></li>
                    </ul>
                </div>
                
                <div>
                    <h4 class="font-semibold mb-4">Company</h4>
                    <ul class="space-y-2 text-gray-400">
                        <li><a href="../../pages/about.html" class="hover:text-white transition-colors">About Us</a></li>
                        <li><a href="../../pages/privacy.html" class="hover:text-white transition-colors">Privacy Policy</a></li>
                        <li><a href="../../pages/terms.html" class="hover:text-white transition-colors">Terms of Service</a></li>
                        <li><a href="../../pages/contact.html" class="hover:text-white transition-colors">Contact</a></li>
                    </ul>
                </div>
                
                <div>
                    <h4 class="font-semibold mb-4">Connect</h4>
                    <div class="flex space-x-4">
               <a href="https://github.com/techuhat" class="text-gray-400 hover:text-white transition-colors" target="_blank" rel="noopener noreferrer">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
                        </a>
                        <a href="https://www.linkedin.com/in/mohdkhanumar/" class="text-gray-400 hover:text-white transition-colors">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"/></svg>
                        </a>
                    </div>
                </div>
            </div>
            
            <div class="border-t border-gray-800 mt-8 pt-8 text-center text-gray-400">
                <p>&copy; 2024 ImagePDF Toolkit. All rights reserved. Design by Tech U ‚ù§Ô∏è</p>
            </div>
        </div>
    </footer>
    
    <!-- Scripts -->
    <script src="../../../../public/js/pdf.min.js"></script>
    <script src="../../../../public/js/pdf-config.js"></script>
    <script src="../../../../public/script.js?v=2.3.1"></script>
    <script>
        // Emergency circuit breaker to prevent infinite loops
        let errorCount = 0;
        const MAX_ERRORS = 10;
        
        const originalConsoleError = console.error;
        console.error = function(...args) {
            errorCount++;
            if (errorCount > MAX_ERRORS) {
                console.warn('Emergency: Too many errors, suppressing further error logging');
                return;
            }
            originalConsoleError.apply(console, args);
        };
        
        // Reset error count after a delay
        setTimeout(() => {
            errorCount = 0;
        }, 5000);
        
        // Add comprehensive error handling to prevent null reference errors
        function safeGetElement(selector, byId = false) {
            try {
                const element = byId ? document.getElementById(selector) : document.querySelector(selector);
                if (!element) {
                    console.warn(`Element not found: ${selector}`);
                }
                return element;
            } catch (error) {
                console.error(`Error getting element ${selector}:`, error);
                return null;
            }
        }
        
        // Safe classList operations with circuit breaker
        let classListOpCount = 0;
        function safeClassListOperation(element, operation, className) {
            classListOpCount++;
            if (classListOpCount > 100) {
                console.warn('Too many classList operations, stopping to prevent infinite loop');
                return false;
            }
            
            if (element && element.classList && typeof element.classList[operation] === 'function') {
                try {
                    if (Array.isArray(className)) {
                        className.forEach(cls => element.classList[operation](cls));
                    } else {
                        element.classList[operation](className);
                    }
                    return true;
                } catch (error) {
                    console.warn(`classList ${operation} failed:`, error.message);
                    return false;
                }
            }
            return false;
        }
        
        // Reset counter periodically
        setInterval(() => {
            classListOpCount = 0;
        }, 1000);
        
        // Global variables for file handling
        let currentFiles = [];
        let processedFiles = [];
        let currentTool = 'pdf-to-doc';
        let conversionMode = 'client'; // 'client' or 'server'
        
        // Configuration for different deployment modes
        const DEPLOYMENT_MODE = 'WITH_BACKEND'; // Options: 'CLIENT_ONLY', 'WITH_BACKEND', 'RENDER'
        
        const BACKEND_CONFIG = {
            // Azure App Service Production URL
            baseUrl: 'https://imagetool-h4dmewahfmg4bkej.eastasia-01.azurewebsites.net',
            
            // For local testing, temporarily use:
            // baseUrl: 'http://localhost:5000',
            
            endpoints: {
                convert: '/pdf-to-docx',
                health: '/health',
                merge: '/pdf-merge',
                split: '/pdf-split',
                compress: '/compress-pdf'
            },
            maxFileSize: 500 * 1024 * 1024, // 500MB for advanced processing
            timeout: 300000 // 5 minutes
        };
        
        // Auto-disable server mode if backend not available
        let serverModeAvailable = DEPLOYMENT_MODE !== 'CLIENT_ONLY';
        
        // Error Management System - Fixed to prevent recursion
        const ErrorManager = {
            errors: [],
            isProcessingError: false, // Prevent recursive calls
            
            // Add an error to the collection
            addError(error, context = '', severity = 'error') {
                // Prevent recursive error processing
                if (this.isProcessingError) {
                    console.warn('Prevented recursive error processing:', error.message);
                    return null;
                }
                
                this.isProcessingError = true;
                
                try {
                    const errorObj = {
                        id: Date.now() + Math.random(),
                        message: error.message || error.toString(),
                        context: context,
                        severity: severity,
                        timestamp: new Date(),
                        stack: error.stack || ''
                    };
                    
                    this.errors.push(errorObj);
                    
                    // Simple console logging without triggering more errors
                    console.warn(`[${severity.toUpperCase()}] ${context}: ${errorObj.message}`);
                    
                    // Only display errors if not in processing state
                    setTimeout(() => {
                        this.displayErrors();
                    }, 0);
                    
                    return errorObj.id;
                } catch (processingError) {
                    console.error('Error in ErrorManager.addError:', processingError);
                    return null;
                } finally {
                    this.isProcessingError = false;
                }
            },
            
            // Clear all errors
            clearErrors() {
                if (this.isProcessingError) return;
                
                this.errors = [];
                this.hideErrorDisplay();
            },
            
            // Display errors in the UI
            displayErrors() {
                if (this.isProcessingError) return;
                
                const errorDisplay = document.getElementById('error-display');
                const errorList = document.getElementById('error-list');
                
                if (!errorDisplay || !errorList) {
                    return;
                }
                
                if (this.errors.length === 0) {
                    this.hideErrorDisplay();
                    return;
                }
                
                // Group errors by severity
                const critical = this.errors.filter(e => e.severity === 'critical');
                const errors = this.errors.filter(e => e.severity === 'error');
                const warnings = this.errors.filter(e => e.severity === 'warning');
                
                let html = '';
                
                // Show critical errors first
                if (critical.length > 0) {
                    html += '<div class="mb-2"><strong>Critical Errors:</strong></div>';
                    critical.forEach(err => {
                        html += `<div class="flex items-start mb-1">
                            <span class="text-red-600 mr-2">üö®</span>
                            <div>
                                <div class="font-medium">${this.sanitizeMessage(err.message)}</div>
                                ${err.context ? `<div class="text-xs opacity-75">Context: ${err.context}</div>` : ''}
                            </div>
                        </div>`;
                    });
                }
                
                // Show regular errors
                if (errors.length > 0) {
                    html += critical.length > 0 ? '<div class="mt-3 mb-2"><strong>Errors:</strong></div>' : '';
                    errors.forEach(err => {
                        html += `<div class="flex items-start mb-1">
                            <span class="text-red-500 mr-2">‚ùå</span>
                            <div>
                                <div>${this.sanitizeMessage(err.message)}</div>
                                ${err.context ? `<div class="text-xs opacity-75">Context: ${err.context}</div>` : ''}
                            </div>
                        </div>`;
                    });
                }
                
                // Show warnings
                if (warnings.length > 0) {
                    html += (critical.length > 0 || errors.length > 0) ? '<div class="mt-3 mb-2"><strong>Warnings:</strong></div>' : '';
                    warnings.forEach(err => {
                        html += `<div class="flex items-start mb-1">
                            <span class="text-yellow-500 mr-2">‚ö†Ô∏è</span>
                            <div>
                                <div>${this.sanitizeMessage(err.message)}</div>
                                ${err.context ? `<div class="text-xs opacity-75">Context: ${err.context}</div>` : ''}
                            </div>
                        </div>`;
                    });
                }
                
                errorList.innerHTML = html;
                if (errorDisplay) {
                    safeClassListOperation(errorDisplay, 'remove', 'hidden');
                }
            },
            
            // Hide error display
            hideErrorDisplay() {
                const errorDisplay = document.getElementById('error-display');
                if (errorDisplay) {
                    safeClassListOperation(errorDisplay, 'add', 'hidden');
                }
            },
            
            // Sanitize error messages for display
            sanitizeMessage(message) {
                return message
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;')
                    .substring(0, 200); // Limit length
            }
        };
        
        // Status Management System
        const StatusManager = {
            // Show conversion status
            showStatus(title, message, isLoading = true) {
                const statusContainer = document.getElementById('conversion-status');
                const statusIcon = document.getElementById('status-icon');
                const statusTitle = document.getElementById('status-title');
                const statusMessage = document.getElementById('status-message');
                
                if (!statusContainer || !statusIcon || !statusTitle || !statusMessage) {
                    console.warn('Status display elements not found');
                    return;
                }
                
                statusTitle.textContent = title;
                statusMessage.textContent = message;
                
                // Update icon based on loading state
                if (isLoading) {
                    safeClassListOperation(statusIcon, 'add', 'animate-spin');
                    statusIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />`;
                } else {
                    safeClassListOperation(statusIcon, 'remove', 'animate-spin');
                    statusIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />`;
                }
                
                safeClassListOperation(statusContainer, 'remove', 'hidden');
            },
            
            // Hide conversion status
            hideStatus() {
                const statusContainer = document.getElementById('conversion-status');
                if (statusContainer) {
                    safeClassListOperation(statusContainer, 'add', 'hidden');
                }
            },
            
            // Update status message only
            updateMessage(message) {
                const statusMessage = document.getElementById('status-message');
                if (statusMessage) {
                    statusMessage.textContent = message;
                }
            }
        };
        
        // Initialize theme and file handling
        if (typeof initTheme === 'function') {
            initTheme();
        } else {
            console.warn('initTheme function not available');
        }
        
        // Initialize file handling using standardized functions from script.js
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                if (typeof setupFileInput === 'function') {
                    setupFileInput();
                } else {
                    console.warn('setupFileInput function not available');
                }
                
                if (typeof setupGlobalDragDrop === 'function') {
                    setupGlobalDragDrop();
                } else {
                    console.warn('setupGlobalDragDrop function not available');
                }
                
                // Setup error management event listeners
                const dismissErrorsBtn = safeGetElement('dismiss-errors', true);
                if (dismissErrorsBtn) {
                    dismissErrorsBtn.addEventListener('click', () => {
                        ErrorManager.clearErrors();
                    });
                }
                
                // Clear any existing errors on page load
                ErrorManager.clearErrors();
                StatusManager.hideStatus();
                
                // Setup global error handling - simplified to prevent recursion
                window.addEventListener('error', (e) => {
                    const message = e.message || '';
                    if (!message.includes('ErrorManager') && !message.includes('Safe Error Boundary')) {
                        console.warn('Global error caught:', e.message);
                        // Don't add to ErrorManager to prevent recursion
                    }
                });
                
                window.addEventListener('unhandledrejection', (e) => {
                    const reason = e.reason || {};
                    const message = reason.message || reason.toString();
                    if (!message.includes('ErrorManager') && !message.includes('Safe Error Boundary')) {
                        console.warn('Promise rejection caught:', message);
                        // Prevent error from propagating if it's a classList error
                        if (message.includes('classList') || message.includes('Cannot read properties of null')) {
                            e.preventDefault();
                        }
                    }
                });
                
            } catch (initError) {
                console.error('Error during initialization:', initError);
                // Fallback error display without dependencies
                if (typeof showToast === 'function') {
                    showToast('‚ö†Ô∏è Some features may not work properly due to initialization errors', 'warning', 5000);
                }
            }
            
            // Check backend availability on page load and auto-disable server mode if needed
            if (conversionMode === 'server' || serverModeAvailable) {
                updateBackendStatus('checking', 'Checking backend availability...');
                
                if (typeof updateProgress === 'function') {
                    updateProgress(0, 'Checking backend availability...');
                    showProgress(true);
                }
                
                const healthCheck = await checkBackendAvailability();
                
                if (typeof showProgress === 'function') {
                    showProgress(false);
                }
                
                if (!healthCheck.available) {
                    // Auto-switch to client mode
                    conversionMode = 'client';
                    serverModeAvailable = false;
                    selectConversionMode('client');
                    
                    // Update status
                    updateBackendStatus('unavailable', 'Server unavailable - Using client-side');
                    
                    // Disable server mode UI
                    const serverModeCard = document.querySelector('[onclick="selectConversionMode(\'server\')"]');
                    if (serverModeCard) {
                        serverModeCard.style.opacity = '0.5';
                        serverModeCard.style.pointerEvents = 'none';
                        serverModeCard.title = 'Backend server not available';
                        
                        const serverRadio = document.getElementById('server-mode');
                        if (serverRadio) {
                            serverRadio.disabled = true;
                        }
                        
                        // Add retry button
                        const retryHtml = `
                            <div class="text-center mt-4">
                                <button onclick="retryBackendConnection()" class="btn-base btn-secondary btn-sm">
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
                                    </svg>
                                    Retry Server Connection
                                </button>
                            </div>
                        `;
                        serverModeCard.insertAdjacentHTML('afterend', retryHtml);
                    }
                    
                    // Show informative message
                    if (healthCheck.reason === 'timeout') {
                        showToast('‚ö° Server unavailable (timeout). Client-side mode selected for instant processing.', 'info', 6000);
                    } else {
                        showToast('üîß Backend server unavailable. Client-side mode provides instant, private processing.', 'info', 6000);
                    }
                } else {
                    // If backend supports PDF‚ÜíDOCX, default to server mode for real DOCX output
                    if (healthCheck.features && healthCheck.features.pdfToDocx) {
                        conversionMode = 'server';
                        selectConversionMode('server');
                        updateBackendStatus('available', 'Server-side conversion available');
                        showToast('üåü Server-side PDF‚ÜíDOCX available. Switched to Server Processing.', 'success', 4000);
                    } else {
                        updateBackendStatus('client-only', 'Client-side processing only');
                    }
                }
            } else {
                updateBackendStatus('client-only', 'Client-side processing only');
            }
        });
        
        // Backend availability check function
        async function checkBackendAvailability() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                const response = await fetch(`${BACKEND_CONFIG.baseUrl}/health`, {
                    method: 'GET',
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    const pdfToDocxCap = !!(data && data.capabilities && data.capabilities.pdf_to_docx);
                    const advancedFeatures = !!(data && data.capabilities && (
                        data.capabilities.pdf_advanced_processing || 
                        data.capabilities.advanced_compression
                    ));
                    
                    return {
                        available: pdfToDocxCap,
                        data: data,
                        features: { 
                            pdfToDocx: pdfToDocxCap,
                            advancedFeatures: advancedFeatures
                        },
                        reason: pdfToDocxCap ? undefined : 'feature_unavailable'
                    };
                } else {
                    return { 
                        available: false, 
                        reason: 'http_error',
                        status: response.status 
                    };
                }
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    return { 
                        available: false, 
                        reason: 'timeout',
                        error: error.message 
                    };
                } else {
                    return { 
                        available: false, 
                        reason: 'network_error',
                        error: error.message 
                    };
                }
            }
        }
        
        // Retry backend connection function
        window.retryBackendConnection = async function() {
            const retryButton = event.target;
            const originalText = retryButton.innerHTML;
            
            updateBackendStatus('checking', 'Retrying connection...');
            
            retryButton.disabled = true;
            retryButton.innerHTML = `
                <svg class="w-4 h-4 animate-spin" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
                </svg>
                Checking...
            `;
            
            const healthCheck = await checkBackendAvailability();
            
            if (healthCheck.available) {
                // Re-enable server mode
                serverModeAvailable = true;
                const serverModeCard = safeGetElement('[onclick="selectConversionMode(\'server\')"]');
                const serverRadio = safeGetElement('server-mode', true);
                
                if (serverModeCard) {
                    serverModeCard.style.opacity = '1';
                    serverModeCard.style.pointerEvents = 'auto';
                    serverModeCard.title = '';
                }
                
                if (serverRadio) {
                    serverRadio.disabled = false;
                }
                
                // Remove retry button
                if (retryButton.parentElement) {
                    retryButton.parentElement.remove();
                }
                
                updateBackendStatus('available', 'Server reconnected');
                if (typeof showToast === 'function') {
                    showToast('üéâ Backend server connection restored! Server-side processing now available.', 'success', 5000);
                }
                
            } else {
                retryButton.disabled = false;
                retryButton.innerHTML = originalText;
                
                const reason = healthCheck.reason === 'timeout' ? 'Connection timeout' : 'Server unavailable';
                updateBackendStatus('unavailable', reason);
                if (typeof showToast === 'function') {
                    showToast(`‚ùå ${reason}. Server-side processing still unavailable.`, 'error', 4000);
                }
            }
        };
        
        // Update backend status indicator
        function updateBackendStatus(status, message) {
            const statusElement = safeGetElement('backend-status', true);
            if (!statusElement) return;
            
            const dot = statusElement.querySelector('div');
            const text = statusElement.querySelector('span');
            
            if (!dot || !text) {
                console.warn('Backend status components not found');
                return;
            }
            
            switch (status) {
                case 'checking':
                    dot.className = 'w-2 h-2 bg-yellow-400 rounded-full mr-2 animate-pulse';
                    text.textContent = message || 'Checking server...';
                    break;
                case 'available':
                    dot.className = 'w-2 h-2 bg-green-500 rounded-full mr-2';
                    text.textContent = message || 'Advanced Backend Available';
                    break;
                case 'unavailable':
                    dot.className = 'w-2 h-2 bg-red-500 rounded-full mr-2';
                    text.textContent = message || 'Server unavailable';
                    break;
                case 'client-only':
                    dot.className = 'w-2 h-2 bg-blue-500 rounded-full mr-2';
                    text.textContent = message || 'Client-side only';
                    break;
            }
        }
        
        // Conversion mode selection - safe version
        window.selectConversionMode = function(mode) {
            try {
                conversionMode = mode;
                const clientRadio = safeGetElement('client-mode', true);
                const serverRadio = safeGetElement('server-mode', true);
                
                if (clientRadio) clientRadio.checked = mode === 'client';
                if (serverRadio) serverRadio.checked = mode === 'server';
                
                // Update UI based on selected mode
                updateModeUI(mode);
                
                // Update file size limits
                updateFileSizeLimits(mode);
            } catch (error) {
                console.warn('Error in selectConversionMode:', error);
                // Fallback to client mode
                conversionMode = 'client';
            }
        };
        
        function updateModeUI(mode) {
            const cards = document.querySelectorAll('.conversion-mode-card');
            cards.forEach(card => {
                if (card && card.classList) {
                    safeClassListOperation(card, 'remove', ['border-blue-400', 'border-purple-400', 'bg-blue-50', 'bg-purple-50']);
                    safeClassListOperation(card, 'add', 'border-gray-200');
                }
            });
            
            if (mode === 'client') {
                const clientCard = document.querySelector('[onclick="selectConversionMode(\'client\')"]');
                if (clientCard && clientCard.classList) {
                    safeClassListOperation(clientCard, 'add', ['border-blue-400', 'bg-blue-50']);
                    safeClassListOperation(clientCard, 'remove', 'border-gray-200');
                }
            } else {
                const serverCard = document.querySelector('[onclick="selectConversionMode(\'server\')"]');
                if (serverCard && serverCard.classList) {
                    safeClassListOperation(serverCard, 'add', ['border-purple-400', 'bg-purple-50']);
                    safeClassListOperation(serverCard, 'remove', 'border-gray-200');
                }
            }
        }
        
        function updateFileSizeLimits(mode) {
            const limitText = document.querySelector('.file-size-limit');
            if (limitText) {
                if (mode === 'server') {
                    limitText.textContent = 'Supports up to 10 PDF files, max 100MB each';
                } else {
                    limitText.textContent = 'Supports up to 10 PDF files, max 50MB each';
                }
            }
        }
        
        // PDF to DOC Converter Logic
        class PDFToDOCConverter {
            constructor() {
                this.files = [];
                this.init();
            }
            
            init() {
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                const fileInput = safeGetElement('file-input', true);
                const convertBtn = safeGetElement('process-btn', true);
                
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => this.handleFileSelect(e.target.files));
                } else {
                    console.error('File input not found');
                }
                
                if (convertBtn) {
                    convertBtn.addEventListener('click', () => this.convertFiles());
                } else {
                    console.error('Convert button not found');
                }
            }
            
            handleFileSelect(fileList) {
                const files = Array.from(fileList);
                const maxSize = conversionMode === 'server' ? BACKEND_CONFIG.maxFileSize : 50 * 1024 * 1024;
                
                const validFiles = files.filter(file => {
                    if (!file.type.includes('pdf') && !file.name.toLowerCase().endsWith('.pdf')) {
                        showToast(`Invalid file type: ${file.name}. Only PDF files are supported.`, 'error');
                        return false;
                    }
                    if (file.size > maxSize) {
                        const maxSizeMB = Math.round(maxSize / (1024 * 1024));
                        showToast(`File too large: ${file.name}. Maximum size is ${maxSizeMB}MB for ${conversionMode} mode.`, 'error');
                        return false;
                    }
                    return true;
                });
                
                this.files = [...this.files, ...validFiles].slice(0, 10);
                this.updateFileList();
                this.updateConvertButton();
                
                if (validFiles.length > 0) {
                    const modeText = conversionMode === 'server' ? 'Advanced Server-side' : 'Client-side';
                    showToast(`üéâ ${validFiles.length} PDF files ready for ${modeText} conversion!`, 'success', 3000);
                }
            }
            
            updateFileList() {
                const fileList = document.getElementById('file-list');
                if (!fileList) {
                    console.warn('File list element not found');
                    return;
                }
                
                fileList.innerHTML = '';
                
                this.files.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'flex items-center justify-between p-4 bg-white dark:bg-gray-800 rounded-lg mb-2 shadow-sm';
                    fileItem.innerHTML = `
                        <div class="flex items-center space-x-3">
                            <div class="w-10 h-10 bg-red-100 dark:bg-red-900 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 text-red-600 dark:text-red-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm4 18H6V4h7v5h5v11z"/>
                                </svg>
                            </div>
                            <div>
                                <p class="font-medium text-gray-900 dark:text-white">${file.name}</p>
                                <p class="text-sm text-gray-500 dark:text-gray-400">${formatFileSize(file.size)}</p>
                            </div>
                        </div>
                        <button onclick="pdfConverter.removeFile(${index})" class="text-red-500 hover:text-red-700 dark:hover:text-red-400">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                            </svg>
                        </button>
                    `;
                    fileList.appendChild(fileItem);
                });
            }
            
            removeFile(index) {
                this.files.splice(index, 1);
                this.updateFileList();
                this.updateConvertButton();
                showToast('File removed from queue', 'warning');
            }
            
            updateConvertButton() {
                const convertBtn = document.getElementById('process-btn');
                if (convertBtn) {
                    convertBtn.disabled = this.files.length === 0;
                }
            }
            
            async convertFiles() {
                if (this.files.length === 0) return;
                
                if (conversionMode === 'server') {
                    await this.convertFilesServerSide();
                } else {
                    await this.convertFilesClientSide();
                }
            }
            
            // Client-side conversion with real PDF processing
            async convertFilesClientSide() {
                // Clear previous errors and show status
                ErrorManager.clearErrors();
                StatusManager.showStatus('Initializing PDF Processor', 'Setting up PDF.js worker...', true);
                showProgress(true, 'Processing PDF files locally...');
                
                try {
                    // Initialize PDF.js using centralized configuration
                    StatusManager.updateMessage('Configuring PDF.js worker...');
                    
                    if (typeof PDFConfig !== 'undefined') {
                        const success = PDFConfig.initWorker({ forceCDN: false });
                        if (!success) {
                            ErrorManager.addError(new Error('PDF.js worker configuration failed'), 'PDF Worker Setup', 'warning');
                            console.warn('PDF.js worker configuration failed, falling back to basic conversion guide');
                        } else {
                            StatusManager.updateMessage('PDF.js worker configured successfully');
                        }
                    } else if (typeof pdfjsLib !== 'undefined') {
                        // Fallback configuration if PDFConfig utility is not available
                        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                        if (isLocalhost) {
                            pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf.worker.min.js';
                        } else {
                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                        }
                        StatusManager.updateMessage('PDF.js worker configured with fallback method');
                    } else {
                        ErrorManager.addError(new Error('PDF.js library not loaded'), 'PDF Library Check', 'critical');
                        throw new Error('PDF.js not available - cannot process PDFs');
                    }
                    
                    let successCount = 0;
                    let warningCount = 0;
                    let errorCount = 0;
                    
                    StatusManager.showStatus('Processing PDF Files', `Starting conversion of ${this.files.length} file(s)...`, true);
                    
                    for (let i = 0; i < this.files.length; i++) {
                        const file = this.files[i];
                        const progress = ((i + 1) / this.files.length) * 90;
                        
                        StatusManager.updateMessage(`Processing ${file.name} (${i + 1}/${this.files.length})`);
                        updateProgress(progress, `Extracting text from ${file.name}...`);
                        
                        try {
                            let fileName, blob, hasRealContent = false;
                            
                            // Try real PDF text extraction if PDF.js is available
                            if (typeof pdfjsLib !== 'undefined') {
                                StatusManager.updateMessage(`Extracting content from ${file.name}...`);
                                const extractedData = await this.extractPDFContent(file);
                                
                                if (extractedData.text.trim().length > 50) {
                                    // Create proper DOC with extracted content
                                    fileName = file.name.replace(/\.pdf$/i, '.doc');
                                    const docContent = this.createRealDOCContent(extractedData.text, extractedData.metadata, file.name);
                                    blob = new Blob([docContent], { type: 'application/msword' });
                                    hasRealContent = true;
                                    successCount++;
                                    
                                    showToast(`‚úÖ Successfully converted: ${fileName} (${extractedData.text.length} characters)`, 'success', 3000);
                                } else {
                                    // Fallback for scanned PDFs or empty PDFs
                                    fileName = file.name.replace(/\.pdf$/i, '_guide.rtf');
                                    const guideContent = this.createPDFConversionGuide(file.name);
                                    blob = new Blob([guideContent], { type: 'application/rtf' });
                                    warningCount++;
                                    
                                    ErrorManager.addError(
                                        new Error(`${file.name} appears to be scanned or contains no extractable text`), 
                                        'Text Extraction', 
                                        'warning'
                                    );
                                    
                                    showToast(`‚ö†Ô∏è ${file.name} appears to be scanned - Generated conversion guide`, 'warning', 4000);
                                }
                            } else {
                                // Fallback when PDF.js is not available
                                fileName = file.name.replace(/\.pdf$/i, '_guide.rtf');
                                const guideContent = this.createPDFConversionGuide(file.name);
                                blob = new Blob([guideContent], { type: 'application/rtf' });
                                warningCount++;
                                
                                ErrorManager.addError(
                                    new Error('PDF.js not available for text extraction'), 
                                    'PDF Processing', 
                                    'warning'
                                );
                                
                                showToast(`‚ÑπÔ∏è PDF.js not loaded. Generated conversion guide for ${file.name}`, 'info', 4000);
                            }
                            
                            downloadFile(blob, fileName);
                            
                        } catch (fileError) {
                            console.error(`Error processing ${file.name}:`, fileError);
                            errorCount++;
                            
                            ErrorManager.addError(fileError, `Processing ${file.name}`, 'error');
                            
                            // Fallback to guide if individual file fails
                            const fileName = file.name.replace(/\.pdf$/i, '_error_guide.rtf');
                            const guideContent = this.createPDFConversionGuide(file.name, `Error: ${fileError.message}`);
                            const blob = new Blob([guideContent], { type: 'application/rtf' });
                            downloadFile(blob, fileName);
                            
                            showToast(`‚ùå Error processing ${file.name}. Generated error guide.`, 'error', 4000);
                        }
                        
                        // Add delay for better UX
                        if (i < this.files.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }
                    
                    // Final status update
                    updateProgress(100, 'Processing complete!');
                    
                    // Show completion status
                    const totalFiles = this.files.length;
                    if (successCount === totalFiles) {
                        StatusManager.showStatus('‚úÖ All Files Converted', `Successfully converted ${successCount} file(s)`, false);
                        showToast(`üéâ Successfully converted all ${successCount} PDF files!`, 'success', 5000);
                    } else if (successCount > 0) {
                        StatusManager.showStatus('‚ö†Ô∏è Partial Success', `Converted ${successCount}/${totalFiles} files successfully`, false);
                        showToast(`üìä Converted ${successCount}/${totalFiles} files. Check error details above.`, 'warning', 5000);
                    } else {
                        StatusManager.showStatus('‚ùå Conversion Failed', `Failed to convert any files properly`, false);
                        showToast(`‚ùå Could not convert any files properly. Check error details.`, 'error', 5000);
                    }
                    
                    // Auto-hide status after a delay
                    setTimeout(() => {
                        StatusManager.hideStatus();
                    }, 10000);
                    
                } catch (error) {
                    console.error('Conversion error:', error);
                    ErrorManager.addError(error, 'Conversion Process', 'critical');
                    StatusManager.showStatus('‚ùå Critical Error', 'Conversion process failed', false);
                    showToast(`‚ùå Critical error: ${error.message}`, 'error', 5000);
                } finally {
                    showProgress(false);
                }
            }
            
            // Extract actual content from PDF using PDF.js
            async extractPDFContent(file) {
                try {
                    const arrayBuffer = await this.readFileAsArrayBuffer(file);
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    
                    let fullText = '';
                    let pageCount = pdf.numPages;
                    let metadata = {
                        pages: pageCount,
                        hasImages: false,
                        imageCount: 0,
                        extractionMethod: 'client-side'
                    };
                    
                    // Extract text from each page
                    for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
                        try {
                            const page = await pdf.getPage(pageNum);
                            const textContent = await page.getTextContent();
                            
                            // Join text items
                            const pageText = textContent.items
                                .map(item => item.str)
                                .join(' ')
                                .replace(/\s+/g, ' ')
                                .trim();
                            
                            if (pageText) {
                                fullText += `\n\n--- Page ${pageNum} ---\n\n${pageText}`;
                            }
                            
                            // Check for images (basic detection)
                            try {
                                const operatorList = await page.getOperatorList();
                                const hasPageImages = operatorList.fnArray.some(fn => 
                                    fn === pdfjsLib.OPS.paintImageXObject || 
                                    fn === pdfjsLib.OPS.paintJpegXObject
                                );
                                
                                if (hasPageImages) {
                                    metadata.hasImages = true;
                                    metadata.imageCount++;
                                }
                            } catch (imgError) {
                                // Continue without image detection if it fails
                            }
                            
                        } catch (pageError) {
                            console.warn(`Error extracting page ${pageNum}:`, pageError);
                            fullText += `\n\n--- Page ${pageNum} (Error reading) ---\n\n`;
                        }
                    }
                    
                    return {
                        text: fullText.trim(),
                        metadata: metadata
                    };
                    
                } catch (error) {
                    console.error('PDF extraction error:', error);
                    throw new Error(`Failed to extract PDF content: ${error.message}`);
                }
            }
            
            // Read file as ArrayBuffer
            readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsArrayBuffer(file);
                });
            }
            
            // Create real DOC content with extracted text
            createRealDOCContent(extractedText, metadata, originalFileName) {
                const currentDate = new Date().toLocaleString();
                
                // Escape RTF special characters
                const escapedText = extractedText
                    .replace(/\\/g, '\\\\')
                    .replace(/\{/g, '\\{')
                    .replace(/\}/g, '\\}')
                    .replace(/\n/g, '\\par ')
                    .replace(/\r/g, '');
                
                // Create RTF document with extracted content
                const rtfContent = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0\\fswiss\\fcharset0 Arial;}{\\f1\\fmodern\\fcharset0 Times New Roman;}}
{\\colortbl;\\red0\\green0\\blue0;\\red0\\green0\\blue255;\\red34\\green139\\blue34;}

\\f1\\fs24

\\b\\fs28\\cf2 Document Converted from PDF\\b0\\fs24\\cf1\\par\\par

\\b Original File:\\b0 ${originalFileName}\\par
\\b Conversion Date:\\b0 ${currentDate}\\par
\\b Pages Processed:\\b0 ${metadata.pages || 'Unknown'}\\par
\\b Processing Method:\\b0 Client-side Text Extraction\\par
\\b Images Detected:\\b0 ${metadata.hasImages ? `Yes (${metadata.imageCount} pages with images)` : 'No'}\\par
\\b Converted by:\\b0 ImagePDF Toolkit\\par\\par

\\line\\par\\par

\\cf3\\b\\fs26 EXTRACTED CONTENT:\\b0\\fs24\\cf1\\par\\par

${escapedText}

\\par\\par\\line\\par

\\i\\fs18 This document was automatically converted from PDF using client-side text extraction.\\par
For better formatting and image support, try the Server processing mode.\\par\\par

${metadata.hasImages ? 'Note: Images were detected but cannot be embedded in client-side mode. Use Server mode for image support.\\par\\par' : ''}

Text extraction quality depends on the original PDF format.\\i0\\fs24\\par

}`;

                return rtfContent;
            }
            
            // Server-side conversion (advanced functionality)
            async convertFilesServerSide() {
                showProgress(true, 'Uploading files to advanced server...');
                
                try {
                    // Check if backend is available with advanced features
                    const isBackendAvailable = await this.checkBackendHealth();
                    if (!isBackendAvailable) {
                        throw new Error('Advanced backend service is not available. Please try client-side mode or contact support.');
                    }
                    
                    const results = [];
                    
                    for (let i = 0; i < this.files.length; i++) {
                        const file = this.files[i];
                        updateProgress(((i + 1) / this.files.length) * 80, `Processing ${file.name} with advanced server...`);
                        
                        try {
                            // Upload and convert file with advanced processing
                            const result = await this.uploadAndConvertFileAdvanced(file);
                            results.push(result);
                            
                            showToast(`‚úÖ Advanced conversion completed: ${file.name}`, 'success', 2000);
                            
                        } catch (fileError) {
                            console.error(`Error processing ${file.name}:`, fileError);
                            showToast(`‚ùå Failed to process ${file.name}: ${fileError.message}`, 'error', 4000);
                        }
                    }
                    
                    updateProgress(100, 'All files processed with advanced features!');
                    
                    if (results.length > 0) {
                        // Download all converted files
                        await this.downloadConvertedFiles(results);
                        showToast(`üéâ Successfully converted ${results.length} file(s) with advanced processing!`, 'success', 5000);
                    }
                    
                } catch (error) {
                    console.error('Advanced server-side processing error:', error);
                    
                    // Show detailed error message
                    let errorMessage = 'Advanced server conversion failed';
                    if (error.message.includes('not available')) {
                        errorMessage = 'Advanced backend server is currently not available';
                    } else if (error.message.includes('timeout')) {
                        errorMessage = 'Server response timeout';
                    } else if (error.message.includes('network')) {
                        errorMessage = 'Network connection error';
                    }
                    
                    showToast(`‚ùå ${errorMessage}. Switching to client-side mode...`, 'warning', 6000);
                    
                    // Automatically fallback to client-side mode
                    try {
                        conversionMode = 'client';
                        selectConversionMode('client');
                        showToast('üîÑ Switched to client-side processing. Starting conversion...', 'info', 4000);
                        await this.convertFilesClientSide();
                    } catch (fallbackError) {
                        console.error('Client-side fallback failed:', fallbackError);
                        showToast(`‚ùå Both server and client-side conversion failed: ${fallbackError.message}`, 'error', 8000);
                    }
                } finally {
                    showProgress(false);
                }
            }
            
            // Advanced file upload and conversion
            async uploadAndConvertFileAdvanced(file) {
                const formData = new FormData();
                formData.append('file', file);
                
                // Add advanced processing options
                formData.append('advanced', 'true');
                
                const response = await fetch(`${BACKEND_CONFIG.baseUrl}${BACKEND_CONFIG.endpoints.convert}`, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        // Don't set Content-Type header, let browser set it for FormData
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `Advanced server error: ${response.status}`);
                }
                
                // Get the DOCX file directly
                const blob = await response.blob();
                const fileName = file.name.replace(/\.pdf$/i, '.docx');
                
                return {
                    originalName: file.name,
                    convertedName: fileName,
                    blob: blob,
                    features: {
                        textExtracted: true,
                        serverProcessed: true,
                        formatPreserved: true,
                        advancedProcessing: true
                    }
                };
            }
            
            // Check backend health
            async checkBackendHealth() {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                    
                    const response = await fetch(`${BACKEND_CONFIG.baseUrl}/health`, {
                        method: 'GET',
                        signal: controller.signal,
                        headers: {
                            'Accept': 'application/json',
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        console.warn(`Backend health check failed with status: ${response.status}`);
                        return false;
                    }
                    
                    const healthData = await response.json();
                    console.log('Backend health check passed:', healthData);
                    return true;
                    
                } catch (error) {
                    console.warn('Backend health check failed:', error);
                    
                    // Show user-friendly message based on error type
                    if (error.name === 'AbortError') {
                        showToast('‚è±Ô∏è Backend server response timeout. Using client-side mode.', 'warning', 5000);
                    } else if (error.message.includes('fetch')) {
                        showToast('üåê Cannot connect to backend server. Using client-side mode.', 'info', 5000);
                    }
                    
                    return false;
                }
            }
            
            // Download converted files
            async downloadConvertedFiles(results) {
                for (const result of results) {
                    try {
                        // Download the blob directly
                        downloadFile(result.blob, result.convertedName);
                        
                        // Show feature summary
                        const features = result.features;
                        if (features.textExtracted || features.serverProcessed) {
                            let summary = [];
                            if (features.textExtracted) summary.push('Advanced text extraction');
                            if (features.serverProcessed) summary.push('Server-side processing');
                            if (features.formatPreserved) summary.push('Format preserved');
                            
                            showToast(`üìÑ ${result.convertedName}: ${summary.join(', ')}`, 'info', 3000);
                        }
                        
                    } catch (downloadError) {
                        console.error(`Error downloading ${result.convertedName}:`, downloadError);
                        showToast(`‚ùå Failed to download ${result.convertedName}`, 'error', 3000);
                    }
                }
            }
            
            createPDFConversionGuide(originalFileName, errorMessage = null) {
                const currentDate = new Date().toLocaleString();
                
                // Create RTF format that Word can open
                const rtfContent = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0\\fswiss\\fcharset0 Arial;}{\\f1\\fmodern\\fcharset0 Courier New;}}
{\\colortbl;\\red0\\green0\\blue0;\\red0\\green0\\blue255;\\red255\\green0\\blue0;}

\\f0\\fs28\\b PDF to DOC Conversion ${errorMessage ? 'Error Guide' : 'Guide'}\\b0\\fs24\\par\\par

\\b Original PDF File:\\b0 ${originalFileName}\\par
\\b Processing Date:\\b0 ${currentDate}\\par
\\b Created by:\\b0 ImagePDF Toolkit\\par

${errorMessage ? `\\cf3\\b Error Encountered:\\b0\\cf1 ${errorMessage}\\par` : ''}\\par

\\line\\par

\\f0\\fs24\\b Real PDF to DOC Conversion Options:\\b0\\par\\par

\\b Option 1: Try Server Mode (Recommended)\\b0\\par
‚Ä¢ Click "Server Processing" mode in our tool\\par
‚Ä¢ Upload your PDF for advanced server-side conversion\\par
‚Ä¢ Get real DOC files with text, images, and formatting\\par\\par

\\b Option 2: Copy-Paste Method\\b0\\par
1. Open your PDF file in any PDF reader\\par
2. Select all text (Ctrl+A)\\par
3. Copy the text (Ctrl+C)\\par
4. Open Microsoft Word\\par
5. Paste the text (Ctrl+V)\\par
6. Save as DOC/DOCX format\\par\\par

\\b Option 3: Online Tools\\b0\\par
‚Ä¢ Google Docs: Upload PDF ‚Üí File ‚Üí Download ‚Üí Word\\par
‚Ä¢ Microsoft Word: File ‚Üí Open ‚Üí Select PDF ‚Üí Convert\\par
‚Ä¢ Adobe Acrobat online converter\\par\\par

\\b Tips for Better Results:\\b0\\par
‚úì Ensure PDF text is selectable (not scanned images)\\par
‚úì Check for password protection before conversion\\par
‚úì Review formatting after conversion\\par
‚úì Use "Save As" instead of "Export" for better compatibility\\par\\par

\\f1\\fs20 This file was generated by ImagePDF Toolkit - Professional PDF & Image Tools\\par
For best results, try our Server processing mode for real PDF conversion!\\f0\\fs24\\par\\par

\\b Note:\\b0 Client-side processing has limitations. For professional conversion with images and formatting, use our cloud processing mode.\\par
}`;

                return rtfContent;
            }
        }
        
        // Initialize converter with error handling
        let pdfConverter;
        try {
            pdfConverter = new PDFToDOCConverter();
            console.log('PDF to DOC converter initialized successfully');
        } catch (converterError) {
            console.error('Error initializing PDF converter:', converterError);
            // Fallback: still allow basic functionality
            pdfConverter = {
                removeFile: function(index) { console.warn('Converter not properly initialized'); }
            };
        }
        
        // Debug logging
        console.log('PDF to DOC tool initialized successfully');
        console.log('Theme system:', typeof initTheme);
        console.log('Toast system:', typeof showToast);
        console.log('Progress system:', typeof showProgress);
        
        // Setup theme toggle
        const themeToggle = safeGetElement('dn', true);
        if (themeToggle) {
            console.log('Theme toggle found:', themeToggle);
            
            // Set initial state based on current theme
            const isDark = document.documentElement && document.documentElement.classList ? 
                          document.documentElement.classList.contains('dark') : false;
            themeToggle.checked = isDark;
            
            // Add event listener
            themeToggle.addEventListener('change', () => {
                console.log('Theme toggle clicked, current state:', themeToggle.checked);
                if (typeof window.toggleTheme === 'function') {
                    window.toggleTheme();
                }
            });
        } else {
            console.error('Theme toggle not found!');
        }
    </script>
    
    <!-- NoScript Fallback -->
    <noscript>
        <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; z-index: 9999; display: flex; align-items: center; justify-content: center; text-align: center; padding: 20px;">
            <div>
                <h1 style="color: #ef4444; margin-bottom: 20px;">JavaScript Required</h1>
                <p style="color: #666; margin-bottom: 20px;">This PDF to DOC converter requires JavaScript to function properly.</p>
                <p style="color: #666;">Please enable JavaScript in your browser and refresh the page.</p>
            </div>
        </div>
    </noscript>
</body>
</html> 




